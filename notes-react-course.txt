why learn react:

- small learning curve;  JSX it allows to be super prod super quickly
- community: one of the best ones out there. 
- the library itself: component is just a user for your UI. component-based architecture; makes building big production apps easy. React renders an re-renders app really quickly; 

react and the react ecosystem

JSX template language to build ui for components

putting html elements inside wrapper div


conditional rendering - consider static data, user input ecosystem, can call functions inside templates

undefined null and booleans are ignored by JSX

//jsx u would like to render
//dom element - where you would like to render it
ReactDOM.render(template, appRoot);

----------------------><------------------------
var variables can define it and redefined it
check playground/es6-let-const 
let doesnt let u redefine let  but can reassign it 
const doenst even let u reassigne it

let and const are function scoped
block scoping


----------------------><------------------------
Arrow functions
es6 arrow functions are always anonymous; es5 we can name it; 
es6 they are anonymous
call expressions: when we call some method on an array or a string
as long as we have just one expression 

-- arguments object is no longer bound with arrow functions
this keyword - no longer bound

----------------------><------------------------

const user = {
    name: 'Joao Viana',
    age: 23,
    location: 'Portugal'
};

function getLocation(location) {
    if(location){
        return <p>Location: {location}</p>;
    } 
}


const templateTwo = (
    <div>
        <h1>{user.name?user.name:'Anonymous'}</h1>
        {(user.age && user.age >= 18)  && <p> Age: {user.age}</p>}
        {getLocation(user.location)}
    </div>
);

templateTwo is just an object for react

class needs to be className in JSX

JSX does not have built-in data binding

----------------------><------------------------

React is super efficient; uses virtual DOM algorithms in JS to determine the minimal number of changes that 
need to be made in order to correctly render the new application 

----------------------><------------------------

onSubmit={function}
 - just want to reference the function, not call it

e.target is gonna point to the elment the event started on
----------------------><------------------------

React components
allow us to break up our app into small reusable chunks
each lil component has it own set of jsx that renders to scree, can handle jSX events
it allows us to create these self contained components


es6 class - react component

class name extends React (which is global class)
you must define render that returns only jsx

custom html element; We use the class name <Classname/> we now have a react component getting rendered

react enforces uppercase first letter; otherwise it wont render; thats how it distinguishes
from <div></div>  and <Classname/>

<Option /> or <Option></Option> is the same thing

----------------------><------------------------
Nesting components
can call class inside another class react component

Component props

data sent to react components, like attributes
takes html attributes and converts 

{this.props.title}

{
    this.props.options.map((option) =>  <Option key={option} optionText ={option}/>)
}
               

events

handleAddOption(e) {
        e.preventDefault();

        const option = e.target.elements.option.value; gets stirng input from form and prevents change of url
 }


using bind to reset contextREAD DOC
----------------------><------------------------
Component state 
when we change the array, the component changes and rerenders itself

react component with component state:
we need a default state
1 - setup default state object  { count : 0} e.g.
2 - Component rendered with default state values;(implicit)
3 - change state based on event;
4 - Componenet re-rendered using new state values
5 - start at step 3

state is just an obj with initial data; 
the state obj can be changed by events, button click, form submisison. 
or even the finishing of a http request that got some dataf rom an api

- react component api is gonna see the state changed and its going to make sure the UI 
gets updated

   //prevents change 
        e.preventDefault();

----------------------><------------------------
stateless functional components

a react component, its a function, unlike the class component
when it is a simple function render; 
in order to simplify components that were simple presentational components
they are just concerned with the presentation of information
not concerned with managing complex state
when they just need to call a function
should have state (class compononents state in one place)

ex:
const User = () => {
    return (
        <div>
            <p>Name: </p>
            <p>Age: </p>
        </div>
    )
}; 


see this:
ReactDOM.render(<User name='Joao' age={23}/>, document.getElementById('app'));

age:number is in {}

similar to this:

ReactDOM.render(React.createElement(User,{ name:'Joao', age:23}), document.getElementById('app'));


----------------------><------------------------
Default prop values
Header.defaultProps = {
    just an object
}

only show if provided: 
{props.subtitle &&  <h2>{props.subtitle}</h2>}


global react var == $r under react dev tools



----------------------><------------------------
in class based components  we have lifecycle methods and they firre
at various times in a given components life. 
so when a component class first gets rendered to the screen, it gets
removed from the screen when something in the component updates like the props and state. 

we will be able to populate the options array with data as the component updates
so we will be able to watch for changes to state and when state changes we will be able to save things

    componentDidMount() {
        console.log('component did mount')
    }

    componentDidUpdate(){
        console.log('component did update')
    } when u update a prop or state
    we can put inside: this.props and this.state

     componentWillUnmount() {
        fires before component unmounts
        like switching pages and rendering something completely new 
    }
check doc on The Component Lifecycle

----------------------><------------------------
localStorage.setItem()
localStorage.getItem()
localStorage.removeItem()
local storage perists between page loads
only works with string data!!
but can typecast numbers to string

so instead of local storage, we can save the information 
in a JSON (js object notation) file: which is just a stirng representation of a js obj
or an array 

JSON.stringify - to json
JSON.parse - back to obj

const json = localStorage.getItem('options');
        const options = JSON.parse(json);
        if(options){
            this.setState(() => ({options: options}));
        }





----------------------><------------------------
webpack is an asset bundler

take all the stuff that makes up our app, with third party components
and spit out a single js file

allows us to organise our js and put it all in one js file
that file is called a bundle contains everything our app needs to return
at the end of the day we just need a script tag 

gulp and grunt does this as well(regarding the script)

webpack - is breaking up all the files in our app into their
own little islands; these islands can communicate then using the Es6 impor and export syntax
we are going to be able to break up our application into multiple files 
that can communicate with one another;

breaking down each component in diff files 

so indecisionapp will require everything from different dirs etc 

able to grab 3rd party dependencies




module.exports = {

}

all the config details for webpack build
is a node thing, a way to expose an obj eg to another file 



module.exports = {
    entry: './src/app.js',
    output: {
        path: '',
        filename: 'bundle.js'
    }
};

on config 

__dirname gives path to indecision-app

path.join node module for the dir

import './utils.js'

console.log('utils.js is running');

export const square = (x) => x*x;

export const add = (a,b) => a+b;

// export{square, add};

//exports - default export - named exports
----------------------><------------------------
we have
exports, 
default export
and named exports


export{square, add, subtract as default};
named exports but theres subtract as default
only can assign one default

import subtract,{square, add} from './utils.js'

see? subtract is before the ,{}
also, can call it a different name than subtract! like whatever
and use that function name on the imported file


in utils.js
can declare subtract 
and then 
export default subtract;

----------------------><------------------------
loader 
lets you customise the behaviour of web pack when it loads a given file

to convert es6 to es5, 
enables u to use jsx etc

babel-loader is gonna allow  us to teach web pack how to run
babel when webpack sees certain files

 module: {
         rules: [{
            loader: 'babel-loader',
            test: /\.js$/  -> checks if file ends with .js
            exclude: /node_modules/
        }]
    }

----------------------><------------------------
export default class AddOption extends React.Component {

look up on webpack, the devtool for sourcemaps

everytime we change something in webpack config, we need to re build it

sourcemaps enable us on chrome dev tools where exactly is the error, on the app.js

interesting script:     "build-babel": "babel src/app.js --out-file=public/scripts/app.js --presets=env,react --watch"
----------------------><------------------------

webpack dev server - comes with features, specific to web pack
seeds up the process between changing our app files and actually seeing those changes reflected in ur broweser


webpack dev server : contentBase, tell the dev server where to find our public files
its good for speed  and local development


----------------------><------------------------
React modals

when onlyr returning with arrow functionsconst 
OptionModal = () => (
    <div>
    some text
    </div>
);

 <OptionModal />
 when you dont need to pass any children

 modal requires 2 props in order to work 
 isOpen - whether or not the modal should be isOpen
 contentLabel = '' -- accessibility purposes


    isOpen={!!props.selectedOption}
    onRequestClose = {props.handleClearSelectedOption}
    contentLabel = "Selected Option"

----------------------><------------------------
SCSS preprocessor and using webpack to compile it 
will be able to take advantage of things like avriables and mixins
and great features from SCSS

need to specifiy a rul in webpack config

 module: {
        rules: [{
            loader: 'babel-loader',
            test: /\.js$/,
            exclude: /node_modules/
        }, {
            test: /\.css$/
        }]
    },
it says that we are looking for any file that ends with .css 

then npm css-loader
and npm style-loader

test: /\.css$/,
            use:
        }]

        use allows us to provide an array of loaders


sass-loader node-sass

  test: /\.scss$/,
            use: [
                'style-loader',
                'css-loader',
                'sass-loader'
            ]

----------------------><------------------------
_base.scss is gonna be used to load a file, which is a partial 
and partials start with an _ 

@import
to import partials to main scss

@import './base/base'

we leave the underscore!!

//BEM block element modifier



Normalize.css 

makes sure that all browsers start from the exact same place
contains tons of code that makes all those elements start on a certain style
and then we build on top of those styles. 
had to import etc 


 test: /\.s?css$/,

 its gonna make the s optional 


check sass::script::functions doc for darken etc

margin-bottom: $xl-size;
    padding: 2.4rem;
    width: 100%;

width to take the length of container
padding to be bigger inside
margin bottom to yup add more margin

----------------------><------------------------




----------------------><------------------------



----------------------><------------------------

